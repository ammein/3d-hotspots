/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/model/model.glb -o ./src/components/Globe.jsx -T 
Files: ./public/model/model.glb [9.57MB] > /Users/ASN74/Documents/codes/Interactive Assets/3d-hotspots/src/components/model-transformed.glb [4.88MB] (49%)
*/

import { useEffect, useMemo, useRef, useState, Suspense, useCallback } from 'react';
import { useGLTF, useAnimations } from '@react-three/drei';
import { useThree } from '@react-three/fiber';
import { KTX2Loader } from 'three-stdlib';
import { useModelDispatch, useModelState } from '@/components/context/ModelManagement';
import Effects from '@/components/Effects';
import { types } from '@theatre/core';
import { useCurrentSheet } from '@theatre/r3f';
import withTheatreManagement from '@/components/hoc/TheatreManagement';
import { Color, Spherical, Vector3 } from 'three';
import { useDebounce } from '@uidotdev/usehooks';
import { useGSAP } from '@gsap/react';
import gsap from 'gsap';
import { useApp } from './context/AppManagement';
import Orbit, { STATE } from '@/components/Orbit';
import { spherical_lerp } from '@/helpers/interpolate';
import Hotspot from '@/components/Hotspot';
import { DEG2RAD } from '@three-math/MathUtils';

/**
 * @typedef {Object} FocusMetadata
 * @property {Array<number> | string} position
 * @property {Array<number> | string} lookAt
 */

/**
 * @typedef {Object} Hotspots
 * @property {string} name
 * @property {string} pointer
 * @property {import('three').Vector3[]} lines
 * @property {FocusMetadata | undefined} focus
 */

useGLTF.setDecoderPath(import.meta.env.VITE_BASE_URL + '/' + import.meta.env.VITE_LOCAL_DRACO_PATH);

const ktx2Loader = new KTX2Loader();
ktx2Loader.setTranscoderPath(import.meta.env.VITE_BASE_URL + '/' + import.meta.env.VITE_LOCAL_KTX_PATH);

const focalRangeDefault = 25.0;

/**
 * Model Component
 * @param {{ url: string, useDraco: boolean, useKTX2: boolean, animationNames: string[], hideItems: [] } & import('@/components/hoc/TheatreManagement').TheatreReturnValue & { ready: boolean }} param0
 * @returns
 */
function Model({ url, useDraco, useKTX2, animationNames = [], hideItems = [], ...rest }) {
  const sheet = useCurrentSheet();

  const dispatch = useModelDispatch();
  const state = useModelState();
  const { metadata } = useApp();

  const {
    Fog: FogTheatreJS,
    Canvas: CanvasTheatreJS,
    HotspotLines: HotspotLinesTheatreJS,
    HotspotCamera: HotspotCameraTheatreJS,
  } = rest.theatre;

  /** @type {{current: import('three').Group}} */
  const groupRef = useRef();

  /** @type {{current: import('three').ShaderMaterial}} */
  const shaderRef = useRef();
  /** @type {{current: import('./Orbit').PowerOrbitControls}} */
  const orbitRef = useRef();

  /** @type {[{ value: number}, Function]} */
  const [initialFog, setinitialFog] = useState({
    value: 0.0,
  });

  /** @type {[{ autoRotate: boolean, enableZoom: boolean, enablePan: boolean, enableRotate: boolean }, Function]} */
  const [orbitSettings, setOrbitSettings] = useState({});

  /** @type {[import('three').Vector3, Function]} */
  const [savedPosition, setPosition] = useState(new Vector3(0, 0, 0));

  /** @type {[Hotspots[], Function]} */
  const [hotspots, setHotspots] = useState([]);
  /** @type {{ gl: import('@react-three/fiber').GLProps, camera: import('three').Camera, controls: import('./Orbit').PowerOrbitControls, scene: import('three').Scene }} */
  const { gl, camera, controls, size } = useThree();

  /** @type {[boolean, Function]} */
  const [focus, setFocus] = useState(false);

  /** @type {[string]} */
  const urlDebounced = useDebounce(url, 1000);

  /**
   * @type {import('three-stdlib').GLTF & import('@react-three/fiber').ObjectMap}
   */
  const gltf = useMemo(() => {
    let gltf;

    // Since useGLTF does not have error handling, this try and catch will try to handle gltf load as possible or return undefined
    try {
      gltf = useGLTF(urlDebounced, useDraco, true, (loader) => {
        loader.setKTX2Loader(ktx2Loader.detectSupport(gl));
      });
    } catch (err) {
      // err argument caught an instanceof Promise as well and needs to initialize second loads.
      // Somehow it causes a bug here due to try wrapper above is still ongoing Promise
      if (err instanceof Promise) {
        gltf = useGLTF(urlDebounced, useDraco, true, (loader) => {
          loader.setKTX2Loader(ktx2Loader.detectSupport(gl));
        });
      }
    }

    /*
      Fixes on every react refresh onClick bind issue.

      When you hot-save a file (React Fast Refresh), your model or primitive loses its React event bindings (like onClick). This happens because <primitive /> does not go through R3F’s JSX reconciliation layer, so event handlers aren’t re-attached after refresh.
    */
    if (gltf) gltf.scene = gltf.scene.clone();

    return gltf;
  }, [urlDebounced]);

  // Error Handling
  if (!gltf) {
    let error = new Error(
      `Looks like you trying to load an invalid model paths. Make sure you don't include 'public' directory to your path.\nReadjust your url again and click button "reset" to initalize model again.\n\nYour error model path URL: "${url}"`
    );

    error.status = 'Model Not Found';
    throw error;
  }

  /** @type {import('three').AnimationClip[] | null} */
  const animations = gltf?.animations ?? null;

  /** @type {typeof useAnimations} */
  const { actions } = useAnimations(animations || [], groupRef);

  const objectClick = useCallback(
    /**
     * Callback
     * @param {import('@react-three/fiber').ThreeEvent<MouseEvent>} e
     * @returns {void}
     */
    (e) => {
      const intersections = e.intersections;

      if (intersections.length > 0 && rest.start && orbitRef.current.state === STATE.NONE && !focus) {
        /** @type {Hotspots} */
        let intersect = hotspots.find(({ pointer, name }) =>
          intersections.some(({ object }) =>
            pointer ? object.name.indexOf(pointer) >= 0 : object.name.indexOf(name) >= 0
          )
        );

        if (intersect) {
          // Cancel Intersect if the hotspot is not towards camera position
          if (intersect.lines[0].dot(camera.position) > 1) {
            controls.saveState();
            setOrbitSettings({
              autoRotate: controls.autoRotate,
              enableRotate: controls.enableRotate,
              enablePan: controls.enablePan,
              enableZoom: controls.enableZoom,
            });
            dispatch({
              type: 'hotspot',
              value: intersect.name,
            });
            setPosition(controls.position0.clone());
          }
        }
      }
    },
    [hotspots, rest.start, focus]
  );

  // This Effect Called Multiple Times (TODO: Debug What causes to loop here...)
  useEffect(() => {
    if (actions && animationNames.length > 0) {
      animationNames.forEach((name) => {
        if (actions[name]) {
          actions[name].play();
        }
      });
    }

    if (hideItems.length > 0 && gltf && gltf.scene) {
      hideItems
        .map((val) => val.trim())
        .filter((val) => val.length > 0 && /^\S*$/g.test(val))
        .forEach((name) => {
          let obj = gltf.scene.getObjectByName(name);

          if (obj) {
            obj.visible = false;
          } else {
            console.warn("Couldn't find the object named: ", name, '\n');
          }
        });
    }

    if (CanvasTheatreJS && CanvasTheatreJS.color) {
      gl.domElement.style.backgroundColor = `${new Color(
        CanvasTheatreJS.color.r,
        CanvasTheatreJS.color.g,
        CanvasTheatreJS.color.b
      )
        .convertSRGBToLinear()
        .getStyle()}`;
    }
  }, [gltf, animationNames, hideItems, CanvasTheatreJS]);

  // Fog Animation Running Once and specified range
  useEffect(() => {
    if (rest.start && rest.theatreObjects && rest.theatreObjects.Fog) {
      // Get only first index and last index for TheatreJS sequence play range
      const FogRange = sheet.sequence
        .__experimental_getKeyframes(rest.theatreObjects.Fog.props.focalRange)
        .flatMap((val, i, total) => (i === 0 || i === total.length - 1 ? val.position : null))
        .filter((v) => v !== null);
      if (FogRange.length > 0) {
        sheet.sequence.play({ range: FogRange });
      }
    }
  }, [rest.start]);

  // Preload GLTF
  useEffect(() => {
    if (urlDebounced.length > 0 && gltf && gltf.scene) {
      useGLTF.preload(urlDebounced);
    }

    if (gltf && gltf.scene && metadata.screens) {
      gltf.scene.traverse((object) => {
        if (object.type === 'Mesh') {
          // Set transparent to true on Mesh Material object so that it can be adjust the opacity later
          object.material.transparent = true;
        }

        if (hideItems.length === 0 && object.type === 'Mesh') {
          // Default set all object to true.
          gltf.scene.getObjectByName(object.name).visible = true;
        }
      });
    }
  }, [urlDebounced, gltf, metadata]); // Run Once

  // Set Hotspot Once
  useEffect(() => {
    if (gltf && gltf.scene && metadata.screens && HotspotLinesTheatreJS) {
      gltf.scene.traverse((object) => {
        if (object.type === 'Mesh') {
          /** @type {Hotspots} */
          let findHotspot = metadata.screens.detail.hotspots.find((val) => val.name === object.name);

          if (findHotspot && HotspotLinesTheatreJS && object.type === 'Mesh' && findHotspot.name === object.name) {
            setHotspots((prev) => {
              // Clone the incoming position and calculate the line and lineText
              let origin = object.position.clone();
              let line = origin.clone().normalize().multiplyScalar(HotspotLinesTheatreJS.scalar);
              let lineText = line.clone().add(new Vector3(0, 0, Math.sign(origin.z) * HotspotLinesTheatreJS.distance));

              // Create the new data object
              const newData = {
                name: findHotspot.name,
                pointer: findHotspot.pointer ? findHotspot.pointer : null,
                lines: [origin, line, lineText],
                focus: findHotspot.focus,
              };

              // Check if a similar hotspot already exists
              const existingIndex = prev.findIndex(
                (hotspot) => hotspot.name === newData.name && hotspot.pointer === newData.pointer
              );

              if (existingIndex !== -1) {
                // If found, mutate the existing hotspot (update it)
                const updatedHotspots = [...prev];
                updatedHotspots[existingIndex] = newData; // Replace the existing hotspot with the new data
                return updatedHotspots;
              } else {
                // If not found, add the new data to the state
                return [...prev, newData];
              }
            });
          }
        }
      });
    }
  }, [HotspotLinesTheatreJS]);

  // When hotspots updated
  useEffect(() => {
    if (hotspots.length > 0) {
      dispatch({
        type: 'hotspot-data',
        value: hotspots,
      });
    }
  }, [hotspots]);

  // When wireframe state updated
  useEffect(() => {
    if (gltf) {
      gltf.scene.traverse((obj) => {
        if (obj.type === 'Mesh' && obj.material.wireframe !== state.wireframe) {
          obj.material.wireframe = state.wireframe;
        }
      });
    }
  }, [state.wireframe, gltf]);

  // Animations
  useGSAP(() => {
    if (FogTheatreJS && rest.loaded && FogTheatreJS.focalRange) {
      let gsapRunnerVal = {
        value: 0,
      };
      gsap.to(gsapRunnerVal, {
        value: FogTheatreJS.focalRange,
        duration: 1.0,
        onUpdateParams: [gsapRunnerVal],
        onUpdate: ({ value }) => setinitialFog({ value }),
      });
    }

    if (HotspotCameraTheatreJS && state.hotspotID.length > 0 && gltf && !focus) {
      /** @type {Hotspots} */
      const getHotspot = hotspots.find((val) => val.name === state.hotspotID);

      const nextCameraLocation = gltf.scene.getObjectByName(state.hotspotID);

      let cameraPos = nextCameraLocation.position,
        cameraLookAt = nextCameraLocation.position;

      if (getHotspot && getHotspot.focus) {
        if (Array.isArray(getHotspot.focus.position)) {
          cameraPos = new Vector3().fromArray(getHotspot.focus.position);
        } else if (typeof getHotspot.focus.position === 'string') {
          cameraPos = gltf.scene.getObjectByName(getHotspot.focus.position).position;
        }

        if (Array.isArray(getHotspot.focus.lookAt)) {
          cameraLookAt = new Vector3().fromArray(getHotspot.focus.lookAt);
        } else if (getHotspot.focus.lookAt) {
          cameraLookAt = gltf.scene.getObjectByName(getHotspot.focus.lookAt).position;
        }
      }

      const positionDistance = cameraPos.clone().normalize().multiplyScalar(HotspotCameraTheatreJS.distance);

      const currentCameraPosition = camera.position.clone();

      // Copy Location
      const locationTween = gsap.to(
        {},
        {
          onStart: () => {
            controls.autoRotate = false;
            controls.enableRotate = false;
          },
          onUpdate: () => {
            const progress = locationTween.progress();
            let newLocation;

            if (HotspotCameraTheatreJS.lerp === 'orbit') {
              newLocation = spherical_lerp(
                currentCameraPosition,
                positionDistance,
                HotspotCameraTheatreJS.orbitDistance,
                progress
              );
            } else if (HotspotCameraTheatreJS.lerp === 'linear') {
              newLocation = gsap.utils.interpolate(currentCameraPosition, positionDistance, progress);
            }

            camera.position.set(newLocation.x, newLocation.y, newLocation.z);

            controls.target.set(cameraLookAt.x, cameraLookAt.y, cameraLookAt.z);
          },
          onComplete: () => {
            controls.enableRotate = orbitSettings.enableRotate;
            controls.enableZoom = orbitSettings.enableZoom;
            controls.enablePan = orbitSettings.enablePan;
            setFocus(true);
          },
          duration: 1,
          ease: 'sine.in',
        }
      );
    } else if (state.hotspotID.length === 0 && focus) {
      const currentCameraPosition = camera.position.clone();
      const backToCameraPosition = savedPosition.clone();

      const tlReturn = gsap.timeline();
      tlReturn.to(
        {},
        {
          onStart: () => {
            // Reset Polar and Azimuth
            controls.minPolarAngle = 0;
            controls.maxPolarAngle = Math.PI;
            controls.minAzimuthAngle = -Infinity;
            controls.maxAzimuthAngle = Infinity;
          },
          onUpdate: () => {
            const progress = tlReturn.progress();

            let newLocation;

            if (HotspotCameraTheatreJS.lerp === 'orbit') {
              newLocation = spherical_lerp(
                currentCameraPosition,
                backToCameraPosition,
                HotspotCameraTheatreJS.orbitDistance,
                progress
              );
            } else if (HotspotCameraTheatreJS.lerp === 'linear') {
              newLocation = gsap.utils.interpolate(currentCameraPosition, backToCameraPosition, progress);
            }

            camera.position.set(newLocation.x, newLocation.y, newLocation.z);

            controls.target.set(0, 0, 0);
          },
          onComplete: () => {
            controls.autoRotate = orbitSettings.autoRotate;
            controls.enableRotate = orbitSettings.enableRotate;
            controls.enableZoom = orbitSettings.enableZoom;
            controls.enablePan = orbitSettings.enablePan;
            setFocus(false);
            controls.reset();
          },
          duration: 0.8,
          ease: 'sine.in',
        }
      );
    }
  }, [rest.loaded, FogTheatreJS, controls, size, gltf, state.hotspotID, HotspotCameraTheatreJS, focus]);

  // Controls Update
  useEffect(() => {
    if (focus) {
      // Get Spherical Coordinate to get azimuth & polar
      const spherical = new Spherical();

      spherical.setFromVector3(
        controls.object.position.clone().sub(controls.target.clone()) // camera - target
      );

      const currentAzimuth = spherical.theta; // azimuth (around Y)
      const currentPolar = spherical.phi; // polar (down from Y)

      controls.minPolarAngle = Math.max(0, currentPolar - HotspotCameraTheatreJS.focusVerticalMinAngle * DEG2RAD);
      controls.maxPolarAngle = Math.min(Math.PI, currentPolar + HotspotCameraTheatreJS.focusVerticalMaxAngle * DEG2RAD);

      // Enable only certain angle rotation
      controls.minAzimuthAngle = currentAzimuth - HotspotCameraTheatreJS.focusHorizontalMinAngle * DEG2RAD;
      controls.maxAzimuthAngle = currentAzimuth + HotspotCameraTheatreJS.focusHorizontalMaxAngle * DEG2RAD;
    }
  }, [focus, controls, HotspotCameraTheatreJS]);

  return (
    <>
      <Suspense fallback={null}>
        {gltf && gltf.scene && (
          <>
            <primitive ref={groupRef} onClick={(e) => objectClick(e)} object={gltf.scene} dispose={null} />
            {hotspots.length > 0 &&
              HotspotLinesTheatreJS &&
              hotspots?.map((val, i) => (
                <Hotspot
                  start={rest.start}
                  key={val.name + i}
                  focus={state.hotspotID === val.name && focus}
                  id={state.hotspotID}
                  hotspotName={val.name}
                  onClose={(e) =>
                    dispatch({
                      type: 'hotspot',
                      value: '',
                    })
                  }
                  geometry={{
                    points: val.lines,
                  }}
                  material={{
                    lineWidth: HotspotLinesTheatreJS.width,
                    color: new Color()
                      .setRGB(
                        HotspotLinesTheatreJS.color.r,
                        HotspotLinesTheatreJS.color.g,
                        HotspotLinesTheatreJS.color.b
                      )
                      .convertSRGBToLinear(),
                  }}
                />
              ))}

            {FogTheatreJS && (
              <Effects
                uniformsFog={{
                  focalRange: !rest.start ? initialFog.value : FogTheatreJS.focalRange,
                  fogColor: new Color(
                    FogTheatreJS.fogColor.r,
                    FogTheatreJS.fogColor.g,
                    FogTheatreJS.fogColor.b
                  ).convertSRGBToLinear(),
                }}
                fogRef={shaderRef}
              />
            )}
          </>
        )}
      </Suspense>
      <Orbit ref={orbitRef} makeDefault rotate={state.hotspotID.length > 0 ? false : true} />
    </>
  );
}

Model.displayName = 'Model';

const theatreJSModel = withTheatreManagement(Model, 'Model Controller', {
  Fog: {
    props: {
      focalRange: types.number(focalRangeDefault, {
        range: [0, 100],
      }),
      fogColor: types.rgba(
        {
          r: 1,
          g: 1,
          b: 1,
          a: 1,
        },
        {
          label: 'Fog Color',
        }
      ),
    },
    options: {
      reconfigure: true,
    },
  },
  HotspotLines: {
    props: {
      scalar: types.number(1.5, {
        range: [1, 10],
        nudgeMultiplier: 0.1,
        label: 'Length',
      }),
      distance: types.number(1.0, {
        range: [0, 10],
        nudgeMultiplier: 0.1,
        label: 'Text Distance',
      }),
      width: types.number(1.0, {
        range: [0, 1],
        nudgeMultiplier: 0.01,
        label: 'Width',
      }),
      color: types.rgba(
        {
          r: 0,
          g: 0,
          b: 0,
          a: 1,
        },
        {
          label: 'Line Color',
        }
      ),
    },
    options: {
      reconfigure: true,
    },
  },
  HotspotCamera: {
    props: {
      distance: types.number(0, {
        range: [0, 100],
        label: 'Focus Distance',
        nudgeMultiplier: 0.1,
      }),
      lerp: types.stringLiteral('orbit', {
        orbit: 'orbit',
        linear: 'linear',
      }),
      orbitDistance: types.number(1, {
        range: [1, 100],
        label: 'Orbit Distance',
        nudgeMultiplier: 0.1,
      }),
      focusHorizontalMinAngle: types.number(30, {
        range: [0, 360],
        label: 'Max Focus Horizontal Angle',
        nudgeMultiplier: 1,
      }),
      focusHorizontalMaxAngle: types.number(30, {
        range: [0, 360],
        label: 'Max Focus Horizontal Angle',
        nudgeMultiplier: 1,
      }),
      focusVerticalMinAngle: types.number(30, {
        range: [0, 360],
        label: 'Max Focus Vertical Angle',
        nudgeMultiplier: 1,
      }),
      focusVerticalMaxAngle: types.number(30, {
        range: [0, 360],
        label: 'Max Focus Vertical Angle',
        nudgeMultiplier: 1,
      }),
    },
    options: {
      reconfigure: true,
    },
  },
  Canvas: {
    props: {
      color: types.rgba(
        {
          r: 1,
          g: 1,
          b: 1,
          a: 1,
        },
        {
          label: 'Canvas Color',
        }
      ),
    },
  },
});

export default theatreJSModel;

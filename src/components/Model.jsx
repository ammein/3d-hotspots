/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/model/model.glb -o ./src/components/Globe.jsx -T 
Files: ./public/model/model.glb [9.57MB] > /Users/ASN74/Documents/codes/Interactive Assets/3d-hotspots/src/components/model-transformed.glb [4.88MB] (49%)
*/

import {
  useEffect,
  useMemo,
  useRef,
  useState,
  memo,
  Suspense,
  useCallback,
} from 'react';
import {
  useGLTF,
  useAnimations,
  PerspectiveCamera,
  Line,
} from '@react-three/drei';
import { useFrame, useThree } from '@react-three/fiber';
import { GLTFLoader, KTX2Loader } from 'three-stdlib';
import withModelManagement from '@/components/hoc/ModelManagement';
import Fog from './Fog';
import { types } from '@theatre/core';
import { editable, refreshSnapshot, useCurrentSheet } from '@theatre/r3f';
import withTheatreManagement from '@/components/hoc/TheatreManagement';
import { Color, Vector3 } from 'three';
import { useDebounce } from 'use-debounce';
import { useGSAP } from '@gsap/react';
import gsap from 'gsap';
import { useApp } from './context/AppManagement';
import Orbit from '@/components/Orbit';

useGLTF.setDecoderPath(
  import.meta.env.VITE_BASE_URL + '/' + import.meta.env.VITE_LOCAL_DRACO_PATH
);

const ktx2Loader = new KTX2Loader();
ktx2Loader.setTranscoderPath(
  import.meta.env.VITE_BASE_URL + '/' + import.meta.env.VITE_LOCAL_KTX_PATH
);

const focalRangeDefault = 25.0;

const EditableCamera = editable(PerspectiveCamera, 'perspectiveCamera');

/**
 * Model Component
 * @param {{ url: string, useDraco: boolean, useKTX2: boolean, animationNames: string[], hideItems: [], wireframe: boolean } | { theatre: import('@/components/hoc/TheatreManagement').TheatreOptionsValues, ready: boolean }} param0
 * @returns
 */
function Model({
  url,
  useDraco,
  useKTX2,
  animationNames = [],
  hideItems = [],
  ...rest
}) {
  const sheet = useCurrentSheet();
  const { metadata } = useApp();

  const {
    Fog: FogTheatreJS,
    Canvas: CanvasTheatreJS,
    HotspotLines: HotspotLinesTheatreJS,
    HotspotCamera: HotspotCameraTheatreJS,
  } = rest.theatre;

  const groupRef = useRef();
  const shaderRef = useRef();
  const orbitRef = useRef();
  /** @type {{current: import('three').Line[]}} */
  const linesRef = useRef([]);
  const [initialFog, setinitialFog] = useState({
    value: 0.0,
  });
  const [hotspots, setHotspots] = useState([]);
  const { gl, camera, controls } = useThree();
  const [pointer, setPointer] = useState('');
  const [storeCamereLocation, setStoreCameraLocation] = useState([0, 0, 0]);
  const [urlDebounced] = useDebounce(url, 1000);

  /**
   * @type {import('three-stdlib').GLTF & import('@react-three/fiber').ObjectMap}
   */
  const gltf = useMemo(() => {
    let gltf;

    // Since useGLTF does not have error handling, this try and catch will try to handle gltf load as possible or return undefined
    try {
      gltf = useGLTF(urlDebounced, useDraco, true, (loader) => {
        loader.setKTX2Loader(ktx2Loader.detectSupport(gl));
      });
    } catch (err) {
      // err argument caught an instanceof Promise as well and needs to initialize second loads.
      // Somehow it causes a bug here due to try wrapper above is still ongoing Promise
      if (err instanceof Promise) {
        gltf = useGLTF(urlDebounced, useDraco, true, (loader) => {
          loader.setKTX2Loader(ktx2Loader.detectSupport(gl));
        });
      }
    }

    return gltf;
  }, [urlDebounced]);

  if (!gltf) {
    let error = new Error(
      `Looks like you trying to load an invalid model paths. Make sure you don't include 'public' directory to your path.\nReadjust your url again and click button "reset" to initalize model again.\n\nYour error model path URL: "${url}"`
    );

    error.status = 'Model Not Found';
    throw error;
  }

  const animations = gltf?.animations ?? null;

  const { actions } = useAnimations(animations || [], groupRef);

  const objectClick = useCallback(
    (e) => {
      /** @type {import('three').Intersection[]} */
      const intersections = e.intersections;

      if (intersections.length > 0) {
        let intersect = hotspots.find(({ pointer }) =>
          intersections.some(({ object }) => object.name.indexOf(pointer) >= 0)
        );

        if (intersect) {
          setPointer(intersect.name);
        }
      }
    },
    [hotspots]
  );

  const setLinesRef = (line, index) => {
    linesRef.current[index] = line;
  };

  useEffect(() => {
    if (rest.start && sheet) {
      sheet.sequence.play();
    }

    if (actions && animationNames.length > 0) {
      animationNames.forEach((name) => {
        if (actions[name]) {
          actions[name].play();
        }
      });
    }

    if (hideItems.length > 0 && gltf && gltf.scene) {
      hideItems
        .map((val) => val.trim())
        .filter((val) => val.length > 0 && /^\S*$/g.test(val))
        .forEach((name) => {
          let obj = gltf.scene.getObjectByName(name);

          if (obj) {
            obj.visible = false;
          } else {
            console.warn("Couldn't find the object named: ", name, '\n');
          }
        });
    }

    if (CanvasTheatreJS && CanvasTheatreJS.color) {
      gl.domElement.style.backgroundColor = `${new Color(
        CanvasTheatreJS.color.r,
        CanvasTheatreJS.color.g,
        CanvasTheatreJS.color.b
      ).getStyle()}`;
    }
  }, [
    actions,
    gltf,
    animationNames,
    hideItems,
    rest.wireframe,
    rest.ready,
    CanvasTheatreJS,
  ]);

  // useFrame(({ camera }) => {
  //   linesRef.current.forEach((line) => {
  //     const opac = line.position.dot(camera.position);

  //     line.material.opacity = opac;
  //   });
  // });

  // Preload GLTF
  useEffect(() => {
    if (urlDebounced.length > 0 && gltf && gltf.scene) {
      useGLTF.preload(urlDebounced);
    }

    if (gltf && gltf.scene && metadata.screens) {
      gltf.scene.traverse((object) => {
        let findHotspot = metadata.screens.detail.hotspots.find(
          (val) => val.name === object.name
        );

        if (
          findHotspot &&
          HotspotLinesTheatreJS &&
          object.type === 'Mesh' &&
          findHotspot.name === object.name
        ) {
          setHotspots((prev) => {
            let data = {};
            let origin = object.position.clone();
            let line = origin
              .clone()
              .normalize()
              .multiplyScalar(HotspotLinesTheatreJS.scalar);
            let lineText = line
              .clone()
              .add(new Vector3(0, 0, -HotspotLinesTheatreJS.distance));
            data = {
              name: findHotspot.name,
              pointer: findHotspot.pointer ? findHotspot.pointer : null,
              lines: [origin.toArray(), line.toArray(), lineText.toArray()],
            };

            return [data];
          });
        }

        if (hideItems.length === 0 && object.type === 'Mesh') {
          // Default set all object to true.
          gltf.scene.getObjectByName(object.name).visible = true;
        }
      });
    }
  }, [urlDebounced, gltf, metadata, HotspotLinesTheatreJS]); // Run Once

  useGSAP(() => {
    if (FogTheatreJS && rest.loaded && FogTheatreJS.focalRange) {
      let gsapRunnerVal = {
        value: 0,
      };
      gsap.to(gsapRunnerVal, {
        value: FogTheatreJS.focalRange,
        duration: 1.0,
        onUpdateParams: [gsapRunnerVal],
        onUpdate: ({ value }) => setinitialFog({ value }),
      });
    }

    if (HotspotCameraTheatreJS && pointer.length > 0 && gltf) {
      // Go to camerea location
      let nextCameraLocation = gltf.scene.getObjectByName(pointer);

      let positionDistance = nextCameraLocation.position
        .clone()
        .normalize()
        .multiplyScalar(HotspotCameraTheatreJS.distance);

      setStoreCameraLocation(camera.position.toArray());

      console.log(positionDistance);

      // Copy Location
      gsap.to(camera.position, {
        x: positionDistance.x,
        y: positionDistance.y,
        z: positionDistance.z,
        onUpdate: () => {
          let description = gltf.scene.getObjectByName(pointer).position;
          orbitRef.current.target = new Vector3(
            description.x,
            description.y,
            description.z
          );
        },
        duration: 1,
      });
    }
    // else if (
    //   pointer.length === 0 &&
    //   !camera.position.equals(cameraLocation)
    // ) {
    // TODO: Reset Camera Position when exit
    // gsap.to(camera.position, {
    //   x: defaultCameraLocation[0],
    //   y: defaultCameraLocation[1],
    //   z: defaultCameraLocation[2],
    //   onUpdate: () => {
    //     camera.lookAt(0, 0, 0);
    //   },
    //   duration: 1,
    // });
    // }
  }, [
    rest.loaded,
    FogTheatreJS,
    gltf,
    rest.hotspotID,
    pointer,
    HotspotCameraTheatreJS,
  ]);

  return (
    <>
      <EditableCamera theatreKey="Camera" makeDefault />
      <Suspense fallback={null}>
        {gltf && gltf.scene && (
          <>
            <primitive
              ref={groupRef}
              onClick={objectClick}
              object={gltf.scene}
            />
            {hotspots.length > 0 &&
              HotspotLinesTheatreJS &&
              hotspots?.map((val, i) => (
                <Line
                  ref={(line) => setLinesRef(line, i)}
                  key={val.name}
                  points={val.lines}
                  lineWidth={HotspotLinesTheatreJS.width}
                  color={new Color('black')}
                />
              ))}
            {FogTheatreJS && (
              <Fog
                ref={shaderRef}
                focalRange={
                  !rest.start ? initialFog.value : FogTheatreJS.focalRange
                }
                fogColor={
                  new Color(
                    FogTheatreJS.fogColor.r,
                    FogTheatreJS.fogColor.g,
                    FogTheatreJS.fogColor.b
                  )
                }
              />
            )}
          </>
        )}
      </Suspense>
      <Orbit ref={orbitRef} rotate={pointer.length > 0 ? false : true} />
    </>
  );
}

const theatreJSModel = withTheatreManagement(memo(Model), 'Model', {
  Fog: {
    props: {
      focalRange: types.number(focalRangeDefault, {
        range: [0, 100],
      }),
      fogColor: types.rgba(
        {
          r: 1,
          g: 1,
          b: 1,
          a: 1,
        },
        {
          label: 'Fog Color',
        }
      ),
    },
  },
  HotspotLines: {
    props: {
      scalar: types.number(1.5, {
        range: [1, 10],
        nudgeMultiplier: 0.1,
        label: 'Length',
      }),
      distance: types.number(1.0, {
        range: [0, 10],
        nudgeMultiplier: 0.1,
        label: 'Distance',
      }),
      width: types.number(1.0, {
        range: [0, 10],
        nudgeMultiplier: 0.1,
        label: 'Width',
      }),
    },
  },
  HotspotCamera: {
    props: {
      distance: types.number(0, {
        range: [0, 100],
        label: 'Scalar Distance',
        nudgeMultiplier: 0.1,
      }),
    },
  },
  Canvas: {
    props: {
      color: types.rgba(
        {
          r: 1,
          g: 1,
          b: 1,
          a: 1,
        },
        {
          label: 'Canvas Color',
        }
      ),
    },
  },
});

export default withModelManagement(theatreJSModel);

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/model/model.glb -o ./src/components/Globe.jsx -T 
Files: ./public/model/model.glb [9.57MB] > /Users/ASN74/Documents/codes/Interactive Assets/3d-hotspots/src/components/model-transformed.glb [4.88MB] (49%)
*/

import { useEffect, useMemo, useRef, useState } from 'react';
import { useGLTF, useAnimations, PerspectiveCamera } from '@react-three/drei';
import { useThree } from '@react-three/fiber';
import { GLTFLoader, KTX2Loader } from 'three-stdlib';
import withModelManagement from '@/components/hoc/ModelManagement';
import Fog from './Fog';
import { types, val } from '@theatre/core';
import { editable, useCurrentSheet } from '@theatre/r3f';
import withTheatreManagement from '@/components/hoc/TheatreManagement';
import { Color } from 'three';
import { useDebounce } from 'use-debounce';
import { useGSAP } from '@gsap/react';
import gsap from 'gsap';

useGLTF.setDecoderPath(
  import.meta.env.VITE_BASE_URL + '/' + import.meta.env.VITE_LOCAL_DRACO_PATH
);

const ktx2Loader = new KTX2Loader();
ktx2Loader.setTranscoderPath(
  import.meta.env.VITE_BASE_URL + '/' + import.meta.env.VITE_LOCAL_KTX_PATH
);

const focalRangeDefault = 25.0;

const EditableCamera = editable(PerspectiveCamera, 'perspectiveCamera');

/**
 * Model Component
 * @param {{ url: string, useDraco: boolean, useKTX2: boolean, animationNames: string[], hideItems: [], wireframe: boolean } | { theatre: import('@/components/hoc/TheatreManagement').TheatreOptionsValues, ready: boolean }} param0
 * @returns
 */
function Model({
  url,
  useDraco,
  useKTX2,
  animationNames = [],
  hideItems = [],
  ...rest
}) {
  const sheet = useCurrentSheet();
  const { Fog: FogTheatreJS } = rest.theatre;
  const group = useRef();
  const shader = useRef();
  const [tempFog, setTempFog] = useState({
    value: 0.0,
  });
  const { gl, scene, camera } = useThree();
  const [urlDebounced] = useDebounce(url, 1000);

  const gltf = useMemo(() => {
    let gltf;

    // Since useGLTF does not have error handling, this try and catch will try to handle gltf load as possible or return undefined
    try {
      gltf = useGLTF(urlDebounced, useDraco, true, (loader) => {
        loader.setKTX2Loader(ktx2Loader.detectSupport(gl));
      });
    } catch (err) {
      // err argument caught an instanceof Promise as well and needs to initialize second loads.
      // Somehow it causes a bug here due to try wrapper above is still ongoing Promise
      if (err instanceof Promise) {
        gltf = useGLTF(urlDebounced, useDraco, true, (loader) => {
          loader.setKTX2Loader(ktx2Loader.detectSupport(gl));
        });
      }
      console.warn(
        "Looks like you trying to load an invalid model paths.\nMake sure you don't include `public` directory to your path...\n",
        err
      );
    }

    return gltf;
  }, [urlDebounced]);

  const animations = gltf?.animations ?? null;

  const { actions } = useAnimations(animations || [], group);

  useEffect(() => {
    if (rest.start && sheet) {
      sheet.sequence.play();
    }

    if (actions && animationNames.length > 0) {
      animationNames.forEach((name) => {
        if (actions[name]) {
          actions[name].play();
        }
      });
    }

    if (hideItems.length > 0 && gltf && gltf.scene) {
      hideItems
        .map((val) => val.trim())
        .filter((val) => val.length > 0 && /^\S*$/g.test(val))
        .forEach((name) => {
          let obj = gltf.scene.getObjectByName(name);

          if (obj) {
            obj.visible = false;
          } else {
            console.warn("Couldn't find the object named: ", name, '\n');
          }
        });
    }

    if (gltf) {
      gltf.scene.traverse((object) => {
        if (object.type === 'Mesh') {
          // console.log(object);
        }

        if (hideItems.length === 0 && object.type === 'Mesh') {
          // Default set all object to true.
          gltf.scene.getObjectByName(object.name).visible = true;
        }
      });
    }
  }, [actions, gltf, animationNames, hideItems, rest.wireframe, rest.ready]);

  // Preload GLTF
  useEffect(() => {
    if (url.length > 0 && gltf && gltf.scene) {
      useGLTF.preload(url);
    }
  }, [url, gltf]); // Run Once

  useGSAP(() => {
    if (rest.loaded && FogTheatreJS.focalRange) {
      let gsapRunnerVal = {
        value: 0,
      };
      gsap.to(gsapRunnerVal, {
        value: FogTheatreJS.focalRange,
        duration: 1.0,
        onUpdateParams: [gsapRunnerVal],
        onUpdate: ({ value }) => setTempFog({ value }),
      });
    }
  }, [rest.loaded, FogTheatreJS]);

  return (
    <>
      <EditableCamera
        theatreKey="Camera"
        makeDefault
        position={[0, 0, 5]}
        zoom={0.81}
      />
      {gltf && gltf.scene && (
        <>
          <primitive ref={group} object={gltf.scene} dispose={null} />
          {FogTheatreJS && (
            <Fog
              ref={shader}
              focalRange={!rest.start ? tempFog.value : FogTheatreJS.focalRange}
              fogColor={
                new Color(
                  FogTheatreJS.fogColor.r,
                  FogTheatreJS.fogColor.g,
                  FogTheatreJS.fogColor.b
                )
              }
            />
          )}
        </>
      )}
    </>
  );
}

const theatreJSModel = withTheatreManagement(Model, 'Model', {
  Fog: {
    props: {
      focalRange: types.number(focalRangeDefault, {
        range: [0, 100],
      }),
      fogColor: types.rgba(
        {
          r: 1,
          g: 1,
          b: 1,
          a: 1,
        },
        {
          label: 'Fog Color',
        }
      ),
    },
    options: {
      reconfigure: import.meta.env.DEV ? true : false,
    },
  },
});

export default withModelManagement(theatreJSModel);

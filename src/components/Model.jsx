/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 ./public/model/model.glb -o ./src/components/Globe.jsx -T 
Files: ./public/model/model.glb [9.57MB] > /Users/ASN74/Documents/codes/Interactive Assets/3d-hotspots/src/components/model-transformed.glb [4.88MB] (49%)
*/

import { useEffect, useMemo, useRef } from "react";
import { useGLTF, useAnimations, PerspectiveCamera } from "@react-three/drei";
import { useThree } from "@react-three/fiber";
import { GLTFLoader, KTX2Loader } from "three-stdlib";
import withModelManagement from "@/components/hoc/ModelManagement";
import Fog from "./Fog";
import { types } from "@theatre/core";
import { editable } from "@theatre/r3f";
import withTheatreManagement from "@/components/hoc/TheatreManagement";
import { Color } from "three";
import { useDebounce } from "use-debounce";

useGLTF.setDecoderPath(
  import.meta.env.VITE_BASE_URL + "/" + import.meta.env.VITE_LOCAL_DRACO_PATH
);

const ktx2Loader = new KTX2Loader();
ktx2Loader.setTranscoderPath(
  import.meta.env.VITE_BASE_URL + "/" + import.meta.env.VITE_LOCAL_KTX_PATH
);

const focalRangeDefault = 25.0;

const EditableCamera = editable(PerspectiveCamera, "perspectiveCamera");

/**
 * Model Component
 * @param {{ url: string, useDraco: boolean, useKTX2: boolean, animationNames: string[], hideItems: [] } | { theatre: import('@/components/hoc/TheatreManagement').TheatreOptionsValues }} param0
 * @returns
 */
function Model({
  url,
  useDraco,
  useKTX2,
  animationNames = [],
  hideItems = [],
  ...rest
}) {
  const { Fog: FogTheatreJS } = rest.theatre;
  const group = useRef();
  const shader = useRef();
  const { gl, scene, camera } = useThree();
  const [urlDebounced] = useDebounce(url, 1000);

  const gltf = useMemo(() => {
    let gltf;

    // Since useGLTF does not have error handling, this try and catch will try to handle gltf load as possible or return undefined
    try {
      gltf = useGLTF(urlDebounced, useDraco, true, (loader) => {
        loader.setKTX2Loader(ktx2Loader.detectSupport(gl));
      });
    } catch (err) {
      // err argument caught an instanceof Promise as well and needs to initialize second loads.
      // Somehow it causes a bug here due to try wrapper above is still ongoing Promise
      if (err instanceof Promise) {
        gltf = useGLTF(urlDebounced, useDraco, true, (loader) => {
          loader.setKTX2Loader(ktx2Loader.detectSupport(gl));
        });
      }
      console.warn(
        "Looks like you trying to load an invalid model paths.\nMake sure you don't include `public` directory to your path...\n",
        err
      );
    }

    return gltf;
  }, [urlDebounced]);

  const animations = gltf?.animations ?? null;

  const { actions } = useAnimations(animations || [], group);

  useEffect(() => {
    if (actions && animationNames.length > 0) {
      animationNames.forEach((name) => {
        if (actions[name]) {
          actions[name].play();
        }
      });
    }

    if (hideItems.length > 0) {
      hideItems.forEach((item) => {
        gltf.scenes.getObjectByName(item).visible = false;
      });
    }

    if (gltf) {
      gltf.scene.traverse((object) => {
        if (object.type === "Mesh") {
          // console.log(object);
        }
      });
    }
  }, [actions, gltf, animationNames, hideItems, rest.wireframe]);

  useEffect(() => {
    if (url.length > 0 && gltf && gltf.scene) {
      console.log("Running Preload");
      useGLTF.preload(url);
    }
  }, [url, gltf]); // Run Once

  return (
    <>
      <EditableCamera
        theatreKey="Camera"
        makeDefault
        position={[0, 0, 5]}
        zoom={0.81}
      />
      {gltf && gltf.scene && (
        <>
          <primitive ref={group} object={gltf.scene} dispose={null} />
          {FogTheatreJS && (
            <Fog
              ref={shader}
              focalRange={FogTheatreJS.focalRange}
              fogColor={
                new Color(
                  FogTheatreJS.fogColor.r,
                  FogTheatreJS.fogColor.g,
                  FogTheatreJS.fogColor.b
                )
              }
            />
          )}
        </>
      )}
    </>
  );
}

const theatreJSModel = withTheatreManagement(Model, "Model", {
  Fog: {
    props: {
      focalRange: types.number(focalRangeDefault, {
        range: [0, 100],
      }),
      fogColor: types.rgba(
        {
          r: 1,
          g: 1,
          b: 1,
          a: 1,
        },
        {
          label: "Fog Color",
        }
      ),
    },
    options: {
      reconfigure: import.meta.env.DEV ? true : false,
    },
  },
});

export default withModelManagement(theatreJSModel);
